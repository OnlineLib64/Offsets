#include <list>
#include <vector>
#include <string.h>
#include <pthread.h>
#include <thread>
#include <cstring>
#include <jni.h>
#include <unistd.h>
#include <fstream>
#include <iostream>
#include <dlfcn.h>
#include <pthread.h>
#include <stdint.h>
#include <cstdint>
#include <semaphore.h>
#include "Includes/Logger.h"
#include "Includes/obfuscate.h"
#include "Includes/Utils.h"
#include "KittyMemory/MemoryPatch.h"
#define targetLibName OBFUSCATE("libUE4.so")
#define targetLibName OBFUSCATE("libanogs.so")
#define targetLibName OBFUSCATE("libRoosterNN.so")
#define targetLibName OBFUSCATE("libAntsVoice.so")
#define targetLibName OBFUSCATE("libswappy.so")
#define targetLibName OBFUSCATE("libhdmpve.so")
#include "Includes/Macros.h"
#include "imgui/json.hpp"
#define _BYTE  uint8_t
#define _WORD  uint16_t
#define _DWORD uint32_t
#define _QWORD uint64_t
#define _OWORD uint64_t

#define _BOOL8 uint64_t
#define _BOOL4 uint64_t

DWORD libanogsBase = 0;
DWORD libUE4Base = 0;
DWORD libanogsAlloc = 0;
DWORD libUE4Alloc = 0;
DWORD NewBase = 0;

using json = nlohmann::json;

std::string originalSignature;
int versionCode;

void randomDelay(int minMs, int maxMs) {
    int range = maxMs - minMs;
    int randomValue = rand() % range + minMs;
    
    
    std::this_thread::sleep_for(std::chrono::milliseconds(randomValue));
}

void readConfig() {
    
    std::ifstream configFile("config.json");
    if (!configFile.is_open()) {
        std::cerr << "Error: Unable to open config.json" << std::endl;
        exit(1);
    }
    
    json config;
    configFile >> config;

    originalSignature = config["f47ac10b-58cc-4372-a567-0e02b2c3d479"];
    versionCode = config["lspConfig"]["4.0"]; 

    std::cout << "f47ac10b-58cc-4372-a567-0e02b2c3d479: " << originalSignature << std::endl;
    std::cout << "4.0 version code: " << versionCode << std::endl;
}

void gameLoop() {

    while (true) {
        std::cout << "Game running... Processing frame..." << std::endl;
        
        randomDelay(100, 500); 
        
        std::this_thread::sleep_for(std::chrono::milliseconds(16));
    }
}

int main() {
    std::cout << "Starting the game loop..." << std::endl;
    gameLoop(); // Start the game loop
    return 0;
}

size_t getLibrarySize(const char *libraryName)
{
    FILE *mapsFile = fopen("/proc/self/maps", "r");
    if (mapsFile == nullptr)
    {
        return 0;
    }

    char line[256];
    size_t size = 0;
    uintptr_t startAddr = 0, endAddr = 0;
    while (fgets(line, sizeof(line), mapsFile))
    {
        if (strstr(line, libraryName))
        {
            sscanf(line, "%lx-%lx", &startAddr, &endAddr);
            size = endAddr - startAddr;
            break;
        }
    }

    fclose(mapsFile);
    return size;
}

char *Offset;


__int64 __fastcall  Fuck ( __int64 a1, __int64 a2, __int64 a3) {
    auto ret = reinterpret_cast<uintptr_t>(__builtin_return_address(0));
    LOGI("ret : %0",ret);
    if (ret == 0xE0970){
        sleep(10000);
    }
}


__int64 __fastcall hsub_3C0A44(__int64 a1)
{
    // Log the hook activation for debugging purposes
    printf("[Hooked] sub_3C0A44 intercepted\n");

    // Bypass the flag check
    if (!*(_BYTE *)(a1 + 48)) {
        printf("[Hooked] Flag check bypassed\n");
        return 0LL; // Return success
    }

    // Bypass the mutex lock
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 8))) {
        printf("[Hooked] Mutex lock bypassed\n");
        return 0LL; // Return success
    }

    // Default success return
    return 0LL;
}


//@YTGENIUS

const void *__fastcall hsub_169688(__int64 a1)
{
    __int64 v1 = a1 + 1064;
    _QWORD *v3 = *(_QWORD **)a1;
    unsigned __int64 v4 = *(_QWORD *)(a1 + 8);
    const void *v6 = nullptr;

    if (v3 == (_QWORD *)v4) {
        // Queue is empty
        return nullptr;
    }

    const void *v7 = (const void *)*v3;
    _QWORD *v5 = v3 + 1;
    v6 = v7;

    while ((unsigned __int64)v5 < v4) {
        *(v5 - 1) = *v5;
        v4 = *(_QWORD *)(a1 + 8);
        ++v5;
    }

    *(_QWORD *)(a1 + 8) = v4 - 8;

    // Debug logging
    if (!v6) {
        // Log null pointer return
        printf("hsub_169688: Returning nullptr\n");
    } else {
        // Log successful return
        printf("hsub_169688: Returning valid pointer: %p\n", v6);
    }

    return v6;
}




__int64 hsub_139D58()
{
    __int64 v0; // x21
    __int64 v1; // x26
    __int64 v2; // x0
    __int64 v3; // x1
    __int64 v4; // x2
    __int64 v5; // x3
    unsigned int v6; // w8

    // Bypassing file check: Replacing `sub_3C7CE4` call.
    // Original: v2 = sub_3C7CE4(v0, "mrpcs_abort.dat");
    v2 = 0; // Ensure `v2` is benign and won't trigger unintended behavior.

    // Setting a safe value for `v6` to avoid termination logic.
    v6 = 13; // Assign a constant that ensures a non-critical function is called.

    // Replace function pointer call with a no-op or safe behavior.
    // Original: return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(v1 + 8LL * v6))(v2, v3, v4, v5);
    return 0; // Return a benign value.
}

__int64 __fastcall sub_3C7CE4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2; // w9
  unsigned int v3; // w8

  while ( 1 )
  {
    v2 = *a1;
    v3 = v2 - *a2;
    if ( v3 )
      break;
    ++a2;
    ++a1;
    if ( !v2 )
      return 0;
  }
  return v3;
}

const void *__fastcall sub_169688_modified(__int64 a1) {
    const void *v6 = nullptr;
   __int64 v11; // x0

    if ( v11 ++ <= 4) {
        if ( (_DWORD)v11 ) {
            v11 = 0;
        }
    }

    return v6;
}

__int64 __fastcall sub_169278_modified(__int64 a1, unsigned __int8 *a2, unsigned int a3) {
    __int64 result = 0xFFFFFFFFLL;
    void *v7;
    __int64 v8 = 0;
    __int64 v9;
    _QWORD *v10;

    if (a2 && a3 - 1 <= 0x3FF) {
        if ((unsigned __int64)((__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3) > 0x400) {
            return 0LL;
        }

        if (*a2 > 0x10u) {
            (a1 + 1064);
            v7 = *(void **)(a1 + 26);
            *(_WORD *)(a1 + 24) = a3;
            memcpy(v7, a2, a3);
           (a1 + 1064);
        }

        if (v8) {
            v9 = v8;
            (a1 + 1064);
            v10 = *(_QWORD **)(a1 + 8);
            if (v10 == *(_QWORD **)(a1 + 16)) {
                (a1);
                v10 = *(_QWORD **)(a1 + 8);
            }
            if (v10) {
                *v10 = v9;
                *(_QWORD *)(a1 + 8) += 8LL;
            }
            (a1 + 1064);
            return 0LL;
        } else {
            return 0LL;
        }
    }
    return result;
}    

//==========================================================

void * hack_thread(void *) {
    LOGI(OBFUSCATE("SCAMMER SHARP LIBRARY READY..."));

    do {
        sleep(1);
    } while (!isLibraryLoaded(targetLibName));
    #if defined(__aarch64__)
//=======================================================
HOOK_LIB_NO_ORIG("libanogs.so", "0xE0970", Fuck); // CRASH FIXER
PATCH_LIB("libanogs.so","0xEEE74","00 00 80 D2 C0 03 5F D6"); // 3rd party
PATCH_LIB("libanogs.so","0xE599C","00 00 80 D2 C0 03 5F D6"); // 3rd party

PATCH_LIB("libanogs.so","0x41DBB0","00 00 80 D2 C0 03 5F D6");// OFFLINE
PATCH_LIB("libanogs.so","0x187998","00 00 80 D2 C0 03 5F D6");// OFFLINE
PATCH_LIB("libanogs.so","0x3EE434","00 00 80 D2 C0 03 5F D6"); // OFFLINE
PATCH_LIB("libanogs.so","0xE856C","00 00 80 D2 C0 03 5F D6");
PATCH_LIB("libanogs.so","0xE8548","00 00 80 D2 C0 03 5F D6");
PATCH_LIB("libanogs.so","0xE850C","00 00 80 D2 C0 03 5F D6");
PATCH_LIB("libanogs.so","0xE8430","00 00 80 D2 C0 03 5F D6");
PATCH_LIB("libanogs.so","0xE83B0","00 00 80 D2 C0 03 5F D6");
PATCH_LIB("libanogs.so","0x4006B4","00 00 80 D2 C0 03 5F D6");
PATCH_LIB("libanogs.so","0x150B38","00 00 80 D2 C0 03 5F D6"); // After ban
PATCH_LIB("libanogs.so","0x169494","00 00 80 D2 C0 03 5F D6"); // After ban
PATCH_LIB("libanogs.so","0x16DB44","00 00 80 D2 C0 03 5F D6"); // After ban

//PATCH_LIB("libanogs.so","0x3C7F58","00 00 80 D2 C0 03 5F D6");
//========================================================

    #endif
    return NULL;
}


__attribute__((constructor))
void lib_main() {
    pthread_t ptid;
    pthread_create(&ptid, NULL, hack_thread, NULL);
}


// Modified By ALBERT RANA

///////////////////////////////////////////////////

  
